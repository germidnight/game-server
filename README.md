# Веб-сервер игры (серверная часть)
---
Игра состоит в поиске потеряных вещей на карте города. Игрок управляет игровым персонажеи (псом) с помощью кнопок "вверх", "вниз", "вправо", "влево" на клавиатуре. Пёс пробегая через потерянную вещь подбирает её и кладёт к себе в сумку, сумка ограниченной ёмкости. Найденные вещи нужно отнести в офис бюро находок. При прохождении офиса бюро находок пёс выкладывает находки, игроку начисляются баллы.

Игра (для игрока) запускается из браузера.

# Опции запуска игры (сервера)
>  -h [ --help ] &emsp;                    вывод сообщения об опциях запуска\
>  -t [ --tick-period ] milliseconds &emsp; установка периода пересчёта состояния игровых персонажей\
>  -c [ --config-file ] file &emsp;        путь до JSON файла настроек игры\
>  -w [ --www-root ] dir &emsp;            путь до файлов frontend части игры (www-root)\
>  --randomize-spawn-points  &emsp;        генерировать игровые персонажи в случайных местах на карте\
>  --save-state-period milliseconds &emsp; установить период автосохранения состояния игры\
>  --state-file file   &emsp;              установить имя файла для автосохранения состояния игры

Файл настроек размещён в файле `data/config.json`.

Frontend часть игры размещена в каталоге `static/`.

# Предоставляемый REST API.

1) получение списка карт,
`/api/v1/maps` — GET-запрос возвращает в теле ответа краткую информацию обо всех картах в виде JSON-массива объектов с полями id и name. Карты в ответе перечислены в том же порядке, что и в конфигурационном файле.

2) получение описания карты с заданным id.
`/api/v1/maps/{id-карты}` — GET-запрос возвращает в теле ответа JSON-описание карты с указанным id.
- Эквивалентен представлению карты из конфигурационного файла.
- содержит поле lootTypes — массив объектов, которые могут быть потеряны на карте.

4) вход в игру.
`/api/v1/game/join` — POST-запрос. Параметры запроса:
- Обязательный заголовок Content-Type должен иметь тип application/json.
- Тело запроса — JSON-объект с обязательными полями userName и mapId: имя игрока и id карты. Имя игрока совпадает с именем пса.
В случае успеха возвращается ответ, обладающий следующими свойствами:
* Статус-код *200 OK*.
* Заголовок Content-Type имеет тип application/json.
* Заголовок Content-Length хранит размер тела ответа.
* Обязательный заголовок Cache-Control имеет значение no-cache.
* Тело ответа — JSON-объект с полями authToken и playerId:
     - Поле playerId — целое число, задающее id игрока.
     - Поле authToken — токен для авторизации в игре — строка, состоящая из 32 случайных шестнадцатеричных цифр.

4) получение списка игроков, находящихся в одной игровой сессии с игроком.
`/api/v1/game/players` — GET-запрос, параметры запроса:
- Обязательный заголовок Authorization: Bearer <токен пользователя>.
В качестве токена пользователя следует передать токен, полученный при входе в игру. Этот токен сервер использует, чтобы аутентифицировать игрока и определить, на какой карте он находится.

5) получение информации о состоянии игры.
`/api/v1/game/state` — GET-запрос, параметры запроса:
- Обязательный заголовок Authorization: Bearer <токен пользователя>.
В случае успеха возвращается ответ, обладающий свойствами:
* Статус-код *200 OK*.
* Заголовок Content-Type: application/json.
* Заголовок Content-Length: <размер тела ответа>.
* Обязательный заголовок Cache-Control: no-cache.
* Тело ответа — JSON объект, в теле ответа содержит:
   -свойство players — объект, ключи которого — это id игроков, а значения — это объекты с полями: pos, speed и dir:
     - pos — массив из двух вещественных чисел, координат x и y игрока на карте.
     - speed — массив из двух вещественных чисел: скорость пса, которым управляет игрок по горизонтальной и вертикальной оси. Измеряется скорость в координатных единицах за секунду. Управление персонажами будет реализовано позже, поэтому скорость объектов пока равна нулю.
     - dir — строка, задающая направление главного героя:
       - "L"  — влево (на запад),
       - "R" — вправо (на восток),
       - "U" — вверх (на север),
       - "D" — вниз (на юг).
  - Информация о потерянных предметах, находящихся на карте - свойство lostObjects типа Object. Его ключи (целые числа) идентификаторы потерянных объектов, а значения — объекты с полями:
    - type — целое число, задающее тип объекта в диапазоне [0, N-1], где N — количество различных типов трофеев, заданных в массиве lootTypes на карте.
    - pos — массив из двух чисел: координаты x и y объекта на карте.
  - Содержимое рюкзака игроков. Поле bag, его тип — массив, содержащий информацию о собранных предметах. Следует передавать предметы в том порядке, в котором они были собраны. Информация задаётся в виде объекта со следующими полями:
    - id (целое число) — идентификатор предмета. Совпадает с тем идентификатором, который имел предмет до того, как его нашли.
    - type (целое число) — тип предмета. Тип также не должен меняться при подборе.
  - Выводится счёт каждого игрока в поле **score**.

6) управление действиями персонажа.
`/api/v1/game/player/action` — POST-запрос.
Параметры запроса:
* Обязательный заголовок Content-Type: application/json.
* Обязательный заголовок Authorization: Bearer <токен пользователя> передаёт токен пользователя, полученный при входе в игру.
* Тело запроса — JSON-объект с полем move, которое принимает одно из значений:
    - "L" — задаёт направление движения персонажа влево (на запад).
    - "R" — задаёт направление движения персонажа вправо (на восток).
    - "U" — задаёт направление движения персонажа вверх (на север).
    - "D" — задаёт направление движения персонажа вниз (на юг).
    - "" — останавливает персонажа.

При обработке этих операций изменится скорость движения персонажа. Буквой s обозначена скорость персонажей на данной карте:
* При движении влево скорость равна {-s, 0}.
* При движении вправо скорость равна {s, 0}.
* При движении вверх скорость равна {0, -s}.
* При движении вниз скорость равна {0, s}.
* При остановке скорость равна {0, 0}.

При успешной обработке запроса ответ на запрос будет обладать следующими свойствами:
* Статус-код *200 OK*.
* Заголовок Cache-Control: no-cache.
* Заголовок Content-Type: application/json.
* Заголовок Content-Length: <размер тела ответа>.
* Тело ответа — пустой JSON-объект.

7) тестовый запрос (работает если опция --tick-period не задана)
`/api/v1/game/tick` — POST-запрос.
Параметры запроса:
* Обязательный заголовок Content-Type: application/json.
* Тело запроса — JSON-объект с целочисленным полем timeDelta, задающим значение параметра Δt в миллисекундах.

При успешном выполнении этого запроса ответ сервера будет обладать следующими свойствами:
* Статус код *200 OK*.
* Заголовок Cache-Control: no-cache.
* Заголовок Content-Type: application/json.
* Заголовок Content-Length: <размер тела ответа>.
* Тело ответа — пустой JSON-объект.
После выполнения этого запроса все персонажи переместятся по правилам перемещения персонажей. Последующие запросы игрового состояния вернут новые координаты персонажей.

8) получение списка рекордсменов **Таблица рекордов хранится в базе данных PostgreSQL. URL базы данных игровому серверу передаётся через переменную окружения GAME_DB_URL.**
`/api/v1/game/records`  — GET-запрос.
> http://gameserver_ip:port/api/v1/game/records?start=10&maxItems=50
Массив ответа должен по умолчанию содержать не более 100 элементов. Количество элементов и индекс стартового элемента задаются опциональными параметрами, передаваемыми в URL-строке запроса:
- start — целое число, задающее номер начального элемента (0 — начальный элемент).
- maxItems — целое число, задающее максимальное количество элементов. Если maxItems превышает 100, должна вернуться ошибка с кодом 400 Bad Request.

Ответ на GET-запрос к этой точке входа должен иметь свойства:
* статус-код 200 OK,
* заголовок Content-Type: application/json,
* заголовок Cache-Control: no-cache,
* заголовок Content-Length: <размер тела ответа>.
В теле ответа массив объектов, со свойствами:
* name — строка, задающая кличку собаки,
* score — число, задающее число,
* playTime — время в секундах, которое игрок провёл в игре с момента входа до момента выхода из игры.

Время, которое игрок провёл в игре, включает в себя время бездействия, прошедшее с момента последней остановки. Элементы массива отсортированы в порядке уменьшения баллов. Элементы с одинаковыми баллами отсортированы в порядке увеличения игрового времени. Элементы с одинаковыми баллами и игровым временем отсортированы по имени (в порядке возрастания).

# Правила перемещения игровых персонажей
* Персонажи-собаки, управляемые игроками, могут перемещаться только вдоль дорог.
* Ширина дороги равна 0.8 координатных единиц. Таким образом собака может удаляться от оси дороги не более, чем на 0.4 координатные единицы.
* За момент времени Δt персонаж, движущийся со скоростью V, должен переместиться на расстояние V * Δt, если нет препятствий.

### Правила генерирования объектов на карте
Класс LootGenerator возвращает количество трофеев, которые должны быть сгенерированы в течение заданного промежутка времени на карте, где находятся N трофеев (loot) и M мародёров (looter).

В игре роль трофеев играют потерянные предметы, а в роли мародёров — собаки, которые собирают эти предметы и доставляют их на базу. Каждый игровой тик используется класс LootGenerator, чтобы узнать, сколько потерянных объектов должно появиться на карте за время, прошедшее с предыдущего игрового тика. Генератор устроен так, чтобы количество трофеев на карте не превышало количество мародёров.

Параметры инициализации LootGenerator задаются в конфигурационном JSON-файле. Для этого используется свойство lootGeneratorConfig.

Получив от генератора количество новых потерянных предметов случайным образом, генерируются для каждого из них тип и координаты:
- Тип предмета — целое число от 0 до K−1 включительно, где K — количество элементов в массиве lootTypes, указанного в конфигурационном файле соответствующей карты.
- Объект генерируется в случайно выбранной точке на случайно выбранной дороге карты.

### Сбор предметов и возвращение предметов в офис.

- Сбор предметов нужно осуществляется во время тика. При этом учитывается перемещение игроков, произошедшее за время тика. Учитываются начальная и конечная координаты каждого игрока. Считается, что игрок двигался равномерно по прямой в течение тика.
- Игроки имеют рюкзак, вместимость которого указывается в конфигурационном файле. Игрок берёт все предметы, мимо которых он проходит, если рюкзак не полон. Игрок пропускает предмет, если рюкзак полон. Проходя мимо базы, игрок убирает все предметы из рюкзака.
- Обрабатываются коллизии в хронологическом порядке. При этом за время одного тика даже с одним игроком может произойти несколько событий. Например игрок может:
  * Взять предмет.
  * Пропустить другой предмет, потому что рюкзак полон.
  * Сдать все предметы на базу.
  * Взять новый предмет.

Если два или более игрока с незаполненными рюкзаками проходят мимо одного предмета, то его берёт тот игрок, который достиг предмет ранее.

Ширина объектов игры такая:
  * Предметы — ширина ноль,
  * Игроки — ширина 0,6,
  * Базы — ширина 0,5.

Половина игрока находится вне дороги при движении по её краю. Так как ширина дороги 0.4, игрок в этом случае не соберёт предмет, лежащий в центре дороги, но может вернуть предметы на базу. Для проверки коллизии используется половина ширины объектов. Например, игрок соберёт предмет, находящийся от него на расстоянии 0.3 или меньше. Предметы вернутся на базу, если до неё от игрока не более 0.55 единиц расстояния: 0.5 / 2 + 0.6 / 2.
Если два события происходят одновременно, порядок их выполнения не определён.

### Начисление очков за сдачу предметов на базу.

В конфигурационном файле в описании каждого предмета задаётся поле **value**. Оно определяет, сколько очков будет начисляться пользователю за находку и возврат предметов подобного типа. Начальное количество очков — ноль. При возврате предметов игроком увеличивается его счёт на стоимость найденного предмета.

# Обработка ошибок
1) В случае ошибки сервер возвращает ответ с соответствующим HTTP-кодом ошибки. Заголовок Content-Type ответа сервера имеет значение application/json. Тело ответа — JSON-объект с полями code и message, содержащими код ошибки и её понятное описание.
2) Если в запросе на получение описания карты указан id несуществующей карты, сервер вернёт ответ со статус-кодом 404 и следующим телом ответа:
Поле code имеет значение “mapNotFound”.
3) Если URI-строка запроса начинается с /api/, но не подпадает ни под один из текущих форматов, сервер вернёт ответ с 400 статус-кодом. Тело ответа содержит такой JSON-объект:
>{\
>  &emsp;"code": "badRequest",\
>  &emsp;"message": "Bad request"\
>}
Поле code имеет значение “badRequest”.

4) Если URI-строка ссылается на несуществующий файл, сервер вернёт ответ со статус-кодом 404 Not Found и Content-Type: text/plain. Текст в ответе произвольный.
5) Если результирующий путь к файлу оказался вне корневого каталога со статическими файлами, сервер вернёт ответ со статус-кодом 400 Bad Request и Content-Type: text/plain. Текст ошибки в ответе произвольный.

6) Если в качестве mapId указан несуществующий id карты, вернётся ответ:
* со статус-кодом *404 Not found*
* заголовками:
    - Content-Length: <размер тела ответа>,
    - Content-Type: application/json,
    - Cache-Control: no-cache.
* Тело ответа — JSON-объект с полями code и message:
    - Поле code — строка *"mapNotFound"*.
    - Поле message — строка с понятным человеку текстом ошибки.

7) Если было передано пустое имя игрока, вернётся ответ:
* со статус-кодом *400 Bad request*
* заголовками:
    - Content-Length: <размер тела ответа>,
    - Content-Type: application/json,
    - Cache-Control: no-cache.
* Тело ответа — JSON-объект с полями code и message:
    - Поле code — строка *"invalidArgument"*.
    - Поле message — строка с понятным человеку текстом ошибки.

8) Если при парсинге JSON или получении его свойств произошла ошибка, вернётся ответ:
* со статус-кодом *400 Bad request*
* заголовками:
    - Content-Length: <размер тела ответа>,
    - Content-Type: application/json
    - Cache-Control: no-cache.
* Тело ответа — JSON-объект с полями code и message:
    - Поле code — строка *"invalidArgument"*.
    - Поле message — строка с понятным человеку текстом ошибки.

9) Если метод запроса отличается от требуемого, вернётся ответ:
* со статус-кодом *405 Method Not Allowed*
* заголовками:
    - Content-Length: <размер тела ответа>,
    - Content-Type: application/json,
    - Allow: список разрешённых методов,
    - Cache-Control: no-cache.
* Тело ответа — JSON-объект с полями code и message:
    - Поле code — строка *"invalidMethod"*.
    - Поле message — строка с понятным человеку текстом ошибки.

10) Если заголовок **Authorization** в запросе отсутствует либо его значение не удовлетворяет требованиям задачи, вернётся ответ со следующими свойствами:
* Статус-код *401 Unauthorized*.
* Заголовок Content-Type: appication/json.
* Заголовок Content-Length: <размер тела ответа>.
* Заголовок Cache-Control: no-cache.
* Тело ответа — JSON-объект с полями code и message:
    - Поле code должно иметь значение *"invalidToken"*.
    - Поле message — содержать понятное человеку описание ошибки.

11) Если заголовок **Authorization** содержит валидное значение токена, но в игре нет пользователя с таким токеном, вернётся ответ со следующими свойствами:
* Статус-код *401 Unauthorized*.
* Заголовок Content-Type: appication/json.
* Заголовок Content-Length: <размер тела ответа>.
* Заголовок Cache-Control: no-cache.
* Тело ответа — JSON-объект с полями code и message:
    - Поле code должно иметь значение *"unknownToken"*.
    - Поле message — содержать понятное человеку описание ошибки.


# Обработка сигналов
После своего старта сервер реагирует на сигналы SIGINT и SIGTERM и корректно завершает свою работу при получении этих сигналов.

# Статические файлы
GET- и HEAD-запросы, в которых URI-строка начинается не с */api/*, интерпретируются сервером как запросы статических файлов внутри соответствующего каталога.
Например, в теле ответа на запрос *GET /images/image1.png HTTP/1.1* сервер отдаст содержимое файла *images/image1*.png относительно каталога со статическими файлами. Ответ содержит следующие заголовки ответа:
- Content-Type — MIME-тип контента, зависящий от расширения файла.
- Content-Length — размер файла в байтах
Значение заголовка Content-Type зависит от расширения запрашиваемого файла:
- .htm, .html: text/html
- .css: text/css
- .txt: text/plain
- .js: text/javascript
- .json: application/json
- .xml: application/xml
- .png: image/png
- .jpg, .jpe, .jpeg: image/jpeg
- .gif: image/gif
- .bmp: image/bmp
- .ico: image/vnd.microsoft.icon
- .tiff, .tif: image/tiff
- .svg, .svgz: image/svg+xml
- .mp3: audio/mpeg
- Для файлов с пустым или неизвестным расширением заголовок Content-Type имеет значение application/octet-stream.

Определение MIME-типа по расширению файла выполняется без учёта регистра символов.

Если URI-строка запроса задаёт путь к каталогу в файловой системе, вернётся содержимое файла *index.html* из этого каталога. 
Сервер трактует URI-строку запроса как URL-encoded.

---
# Логирование

* Для логирования использван Boost::Log.
* Логи пишутся в стандартный вывод, чтобы их удобно было читать извне docker-контейнера.
* Формат JSON: отдельный объект на каждой строке.
JSON-запись представляет собой объект с такими полями:
- timestamp — время логирования в формате ISO (полученное из объекта записи и преобразованное функцией to_iso_extended_string),
- message — сообщение,
- data — произвольные данные в виде JSON-объекта, переданные в лог через атрибут.

**В сервере логируются следующие события:**
1) запуск сервера,
2) остановка сервера,
3) получение запроса,
4) формирование ответа,
5) возникновение ошибки.

### Формат выходных данных
Ниже приводятся значения полей записи, которые поступают в stdout при каждом случае логирования:
1) При запуске сервера:
  * message — строка *"server started"*;
  * data — объект с полями:
    - port — порт, на котором работает сервер (обычно 8080),
    - address — адрес интерфейса (обычно 0.0.0.0).
2) При остановке сервера:
  * message — строка *"server exited"*;
  * data — объект с полями:
    - code — код возврата (0 при успехе, *EXIT_FAILURE* при ошибке),
    - exception — если выход по исключению, то описание исключения (```std::exception::what()```).
3) При получении запроса:
  * message — строка *"request received"*;
  * data — объект с полями:
    - ip — IP-адрес клиента (полученный через ```endpoint.address().to_string())```,
    - URI — запрошенный адрес,
    - method — использованный метод HTTP.
4) При формировании ответа:
  * message — строка *"response sent"*;
  * data — объект с полями:
    - ip — IP-адрес клиента (полученный через ```endpoint.address().to_string()```),
    - response_time — время формирования ответа в миллисекундах (целое число).
    - code — статус-код ответа, например, 200 (```http::response<T>::result_int()```).
    - content_type — строка или ```null```, если заголовок в ответе отсутствует.
5) При возникновении сетевой ошибки:
  * message — строка *"error"*;
  * data — объект с полями:
    - code — код ошибки (```beast::error_code::value()```).
    - text — сообщение ошибки (```beast::error_code::message()```).
    - where — место возникновения (```read, write, accept```).

Также ко всем выводимым сообщениям добавляется поле *"timestamp"*.

# Возможность сохранения игрового состояния в файл и восстановления состояние из файла при старте.

- Параметр **--state-file <путь-к-файлу>** задаёт путь к файлу, в который приложение должно сохранять своё состояние в процессе работы, а при старте — восстанавливать.
Если параметр не задан, игровой сервер всегда запускается с чистого листа и не сохраняет своё состояние в файл.
Когда параметр задан и сервер завершает работу, получив сигналы SIGINT и SIGTERM, программа сохранит на диск своё текущее состояние.

- Параметр **--save-state-period <игровое-время-в-миллисекундах>** задаёт период автоматического сохранения состояния сервера.
Сохранение происходит синхронно с ходом игровых часов, если с момента предыдущего сохранения состояния прошло не меньше указанного времени. Если параметр не задан, состояние сохранится автоматически только перед завершением работы сервера, когда ему отправлены сигналы SIGINT и SIGTERM.
Этот параметр игнорируется, если запустить сервер без параметра **--state-file**.

- Когда в командной строке сервера указан параметр **--state-file** и по указанному пути есть файл, сервер восстановит своё состояние из этого файла.

- Если при восстановлении состояния возникла ошибка, например, в файле есть некорректные данные, сервер :
* в log выведет сообщение об ошибке;
* завершит работу и вернёт из функции код ошибки EXIT_FAILURE.

- Если файл, путь к которому задан в **--state-file**, на диске не существует, сервер начнёть работу с чистого листа.

Сервер использует игровое время для определения моментов автоматического сохранения состояния. То есть сохранение происходит в те моменты, когда происходит обновление игровых часов по HTTP-запросу */api/v1/game/tick* либо автоматически, если сервер был запущен с параметром командой строки **--tick-period**.

Состояние, которое сохраняется на диск, включает:
- информацию обо всех динамических объектах на всех картах — собаках и потерянных предметах;
- информацию о токенах и идентификаторах пользователей, вошедших в игру.

# Завершение игры (неактивность персонажа) и сохранение в БД PostgreSQL результатов игроков

Если игрок, управляющий собакой, какое-то время не проявляет активность, его собака высвобождается от работы и отправляется на покой. Токен бездействующего игрока аннулируется, сервер его не принимает. Трудовые заслуги пса записываются в таблицу рекордов:
- имя пса;
- набранные очки;
- время, которое пёс провёл в игре с момента входа в игру до момента выхода на заслуженный отдых.

Время бездействия пса — непрерывный промежуток времени, в течение которого скорость пса была равна нулю. Например, если при допустимом времени бездействия, равном 1 минуте, в момент времени t=0:00 пёс начал двигаться и остановился в момент времени
t1=5:25, то в момент времени t2=6:25 пёс уйдёт на покой, если не начнёт двигаться.
